#pragma once

#if !defined(__IAR_SYSTEMS_ICC__ )
	#include <type_traits>
#else

#include <!cpp/wrapper/cstdint>

namespace std {
struct true_type {
	enum { value = true };
};
struct false_type {
	enum { value = false };
};

template<class T1, class T2> struct is_same : public false_type {  };
template<class T> struct is_same<T, T> : public true_type {  };

template<bool isEnableArg, class TArg> struct enable_if;
template<class TArg> struct enable_if<true, TArg> {
	typedef TArg type;
};

template<bool isEnableArg, class TArg, class FArg> struct conditional;
template<class TArg, class FArg> struct conditional<true, TArg, FArg> {
	typedef TArg type;
};
template<class TArg, class FArg> struct conditional<false, TArg, FArg> {
	typedef FArg type;
};


template <class T> struct is_integral : public false_type {};
template <class T> struct is_integral<const T> : public is_integral<T> {};
template <class T> struct is_integral<volatile const T> : public is_integral<T>{};
template <class T> struct is_integral<volatile T> : public is_integral<T>{};

//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)
// as an extension we include long long, as this is likely to be added to the
// standard at a later date
template<> struct is_integral<unsigned char> : public true_type {};
template<> struct is_integral<unsigned short> : public true_type{};
template<> struct is_integral<unsigned int> : public true_type{};
template<> struct is_integral<unsigned long> : public true_type{};

template<> struct is_integral<signed char> : public true_type{};
template<> struct is_integral<short> : public true_type{};
template<> struct is_integral<int> : public true_type{};
template<> struct is_integral<long> : public true_type{};

template<> struct is_integral<char> : public true_type{};
template<> struct is_integral<bool> : public true_type{};

#ifdef UINT64_MAX
	template<> struct is_integral<uint64_t> : public true_type{};
	template<> struct is_integral<int64_t> : public true_type{};
#endif

template <class T> struct is_signed : public false_type {};
template <class T> struct is_signed<const T> : public is_signed<T> {};
template <class T> struct is_signed<volatile const T> : public is_signed<T>{};
template <class T> struct is_signed<volatile T> : public is_signed<T>{};

//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)
// as an extension we include long long, as this is likely to be added to the
// standard at a later date
template<> struct is_signed<char> : public true_type {};
template<> struct is_signed<short> : public true_type{};
template<> struct is_signed<int> : public true_type{};
template<> struct is_signed<long> : public true_type{};

#ifdef UINT64_MAX
	template<> struct is_signed<int64_t> : public true_type{};
#endif

template <class T> struct is_unsigned : public false_type {};
template <class T> struct is_unsigned<const T> : public is_unsigned<T> {};
template <class T> struct is_unsigned<volatile const T> : public is_unsigned<T>{};
template <class T> struct is_unsigned<volatile T> : public is_unsigned<T>{};

//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)
// as an extension we include long long, as this is likely to be added to the
// standard at a later date
template<> struct is_unsigned<unsigned char> : public true_type {};
template<> struct is_unsigned<unsigned short> : public true_type{};
template<> struct is_unsigned<unsigned int> : public true_type{};
template<> struct is_unsigned<unsigned long> : public true_type{};

#ifdef UINT64_MAX
	template<> struct is_unsigned<uint64_t> : public true_type{};
#endif

template <class T> struct make_unsigned {};
template <class T> struct make_unsigned<const T> { typedef typename make_unsigned<T>::type const type; };
template <class T> struct make_unsigned<volatile const T> { typedef typename make_unsigned<T>::type volatile const type; };
template <class T> struct make_unsigned<volatile T> { typedef typename make_unsigned<T>::type volatile type; };

//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)
// as an extension we include long long, as this is likely to be added to the
// standard at a later date
template<> struct make_unsigned<signed char> { typedef unsigned char type; };
template<> struct make_unsigned<short> { typedef unsigned short type; };
template<> struct make_unsigned<int> { typedef unsigned int type; };
template<> struct make_unsigned<long> { typedef unsigned long type; };

#ifdef UINT64_MAX
	template<> struct make_unsigned<int64_t> { typedef uint64_t; };
#endif

template <class T> struct make_signed {};
template <class T> struct make_signed<const T> { typedef typename make_signed<T>::type const type; };
template <class T> struct make_signed<volatile const T> { typedef typename make_signed<T>::type volatile const type; };
template <class T> struct make_signed<volatile T> { typedef typename make_signed<T>::type volatile type; };

//* is a type T an [cv-qualified-] integral type described in the standard (3.9.1p3)
// as an extension we include long long, as this is likely to be added to the
// standard at a later date
template<> struct make_signed<unsigned char> { typedef signed char type; };
template<> struct make_signed<unsigned short> { typedef signed short type; };
template<> struct make_signed<unsigned int> { typedef signed int type; };
template<> struct make_signed<unsigned long> { typedef signed long type; };

#ifdef UINT64_MAX
	template<> struct make_signed<uint64_t> { typedef int64_t; };
#endif

} //# namespace std
#endif
